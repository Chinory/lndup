#!/usr/bin/env node
'use strict'
const _path = require('path')
const BASENAME = _path.basename(process.argv[1])
const opts = (() => {
  const parse = require('pargv-lite')
  const options = {
    action: { def: true, set: ['n', 'dry-run'] },
    verbose: { def: false, set: ['v', 'verbose'] },
    prompt: { def: true, set: ['q', 'quiet'] },
    stdin: { def: false, set: ['i', 'stdin'] },
    fileFilters: { def: [], set: ['f', 'filter-file'] },
    dirFilters: { def: [], set: ['d', 'filter-dir'] },
    extraKeys: { def: [], set: ['k', 'key'] },
    help: { def: false, set: ['h', 'help'] },
    version: { def: false, set: ['version'] },
    hasher: { def: false, set: ['hasher'] }
  }
  try {
    return parse(process.argv.slice(2), options)
  } catch (err) {
    console.error(`${BASENAME}: ${err.message}`)
    console.error(`Try '${BASENAME} --help' for more information.`)
    process.exit(1)
  }
})()

if (process.argv.length < 2 || opts.help) {
  console.log(`Usage: ${BASENAME} [options] [paths]`)
  console.log("\
Hardlink duplicate files.\n\
\n\
Options:\n\
  -n, --dry-run  don't link\n\
  -v, --verbose  explain what is being done\n\
  -q, --quiet    don't output extra information\n\
  -i, --stdin    read more paths from stdin\n\
\n\
  -f, --filter-file <function>  add a file filter:\n\
          (stats: fs.Stats, path: string): boolean\n\
  -d, --filter-dir  <function>  add a directory filter:\n\
          (stats: fs.Stats, path: string, files: string[]): boolean\n\
\n\
  -k, --key  <function>  add a key to distinguish files:\n\
          (stats: fs.Stats, path: string): any\n\
\n\
  -h, --help     display this help and exit\n\
      --version  output version information and exit\n\
\n\
See <https://github.com/chinory/lndup>"
  )
} else if (opts.version) {
  console.log('lndup v1.2.0')
} else {
  const HASH_ALGORITHM = 'sha1'
  const HASH_LENGTH = 20
  if (opts.hasher) {
    const noop = () => {}
    const fs = require('fs')
    const crypto = require('crypto')
    const readline = require('readline')
    const BUFSIZE = 1024 ** 2 * 16
    const FAIL = Buffer.alloc(HASH_LENGTH)
    const buff = Buffer.allocUnsafe(BUFSIZE)
    readline.createInterface({input: process.stdin})
      .on('line', line => {
        if (line.length === 0) process.exit()
        let fd, digest
        try {
          fd = fs.openSync(line, 'r')
          let len = fs.fstatSync(fd).size
          const hasher = crypto.createHash(HASH_ALGORITHM)
          while (len > BUFSIZE) {
            fs.readSync(fd, buff, 0, BUFSIZE, null)
            hasher.update(buff)
            len -= BUFSIZE
          }
          fs.readSync(fd, buff, 0, len, null)
          hasher.update(buff.slice(0, len))
          digest = hasher.digest()
        } catch (err) {
          process.stdout.write(FAIL)
          process.stderr.write(`#${err}\n`)
        }
        if (fd) {
          fs.close(fd, noop)
          if (digest) {
            process.stdout.write(digest)
          }
        }
      })
  } else {
    const os = require('os')
    const fs = require('fs')
    const crypto = require('crypto')
    const readline = require('readline')
    const childProcess = require('child_process')

    const SIZE_UNIT = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
    const szstr = function (size) {
      for (var i = 0; size >= 1024 && i < 8; ++i) size /= 1024
      return size.toFixed(i) + SIZE_UNIT[i]
    }

    const tprintf = function () {
      const maxlen = []
      for (const line of arguments) {
        for (const i in line) {
          line[i] = line[i].toString()
          if (maxlen[i] === undefined || line[i].length > maxlen[i]) {
            maxlen[i] = line[i].length
          }
        }
      }
      for (const line of arguments) {
        for (const i in line) {
          line[i] = line[i].padStart(maxlen[i])
        }
        console.log(line.join('  '))
      }
    }

    const report = function (err) {
      return console.error(`#${err}`)
    }

    const reportIf = function (err) {
      if (err) return report(err)
    }

    const hasher = function (callback, n) {
      var procs = []
      var queue = []
      var i = n
      function onerror (chunk) {
        return process.stderr.write(chunk)
      }
      function spawn () {
        const q = []
        const p = childProcess.spawn(process.argv0, [process.argv[1], '--hasher'], {windowsHide: true})
        p.stdout.on('readable', () => {
          for (var buff; (buff = p.stdout.read(HASH_LENGTH)) !== null;) {
            callback(buff, q.shift())
          }
        })
        p.stderr.on('data', onerror)
        procs.push(p)
        queue.push(q)
      }
      function send (path, extra) {
        queue[i].push(extra)
        procs[i].stdin.write(`${path}\n`)
        if (++i === n) i = 0
      }
      function kill () {
        for (const p of procs) p.stdin.write('\n')
      }
      do { spawn() } while (--i > 0)
      return [send, kill]
    }

    const link = function (src, dst) {
      const sav = `${dst}.${crypto.randomBytes(8).toString('hex')}`
      fs.renameSync(dst, sav)
      try {
        fs.linkSync(src, dst)
      } catch (err) {
        try {
          fs.renameSync(sav, dst)
        } catch (err) {
          console.error(`mv -f -- '${sav}' '${dst}' #${err}`)
        }
        throw err
      }
      try {
        fs.unlinkSync(sav)
      } catch (err) {
        console.error(`rm -f -- '${sav}' #${err}`)
      }
    }

    class DefaultMap extends Map {
      getArray (key) {
        if (this.has(key)) {
          return this.get(key)
        } else {
          let value = []
          this.set(key, value)
          return value
        }
      }
      getMap (key) {
        if (this.has(key)) {
          return this.get(key)
        } else {
          let value = new DefaultMap()
          this.set(key, value)
          return value
        }
      }
    }

    const MapDeepIterator = function * (map, maxDepth) {
      if (maxDepth < 1) {
        yield map
        return
      }
      for (const stack = [map.values()]; stack.length > 0;) {
        const result = stack[stack.length - 1].next()
        if (result.done) {
          stack.pop()
        } else if (stack.length < maxDepth && result.value instanceof Map) {
          stack.push(result.value.values())
        } else {
          yield result.value
        }
      }
    }

    const probe = function (paths) {
      return new Promise(resolve => {
        if (opts.prompt) {
          console.time('#Time: probe')
        }
        var cbs = 0
        var devMap = new DefaultMap()
        var pathState = new Map()
        var st = {
          selectCount: 0,
          selectSize: 0,
          statCount: 0,
          statSize: 0,
          readdirCount: 0,
          readdirSize: 0
        }
        function done () {
          if (opts.prompt) {
            tprintf(
              ['#Stat: probe: readdir', szstr(st.readdirSize), st.readdirCount],
              ['#Stat: probe: stat   ', szstr(st.statSize), st.statCount],
              ['#Stat: probe: select ', szstr(st.selectSize), st.selectCount]
            )
            console.timeEnd('#Time: probe')
          }
          return resolve(devMap)
        }
        function readdir (path, stats) {
          ++cbs
          return fs.readdir(path, (err, files) => {
            --cbs
            st.readdirCount++
            if (err) {
              report(err)
            } else if (paths.filter.dir(stats, path, files)) {
              for (const name of files) {
                const pathname = _path.join(path, name)
                st.readdirSize += Buffer.byteLength(pathname)
                stat(pathname)
              }
            }
            if (cbs === 0) return done()
          })
        }
        function stat (path) {
          if (!pathState.has(path)) {
            pathState.set(path, false)
            ++cbs
            return fs.lstat(path, (err, stats) => {
              --cbs
              st.statCount++
              if (err) {
                report(err)
              } else {
                st.statSize += stats.size
                if (pathState.get(path) === false) {
                  pathState.set(path, true)
                  if (stats.isDirectory()) {
                    return readdir(path, stats)
                  } else if (stats.isFile() && stats.size > 0 && paths.filter.file(stats, path)) {
                    st.selectCount++
                    st.selectSize += stats.size
                    let map = devMap.getMap(stats.dev).getMap(stats.size)
                    for (const key of paths.exkeys(stats, path)) {
                      map = map.getMap(key)
                    }
                    map.getMap('').getArray(stats.ino).push(path)
                  }
                }
              }
              if (cbs === 0) return done()
            })
          }
        }
        if (paths.array) {
          for (const path of paths.array) {
            stat(_path.join(path))
          }
        }
        if (paths.readline) {
          ++cbs
          paths.readline.on('line', (path) => stat(_path.join(path)))
            .on('close', () => { if (--cbs === 0) return done() })
        }
      })
    }
    const verify = function (devMap) {
      const HASHER_N = os.cpus().length
      const SMALLS_SIZE = 1024 * 8
      return new Promise(resolve => {
        if (opts.prompt) {
          console.time('#Time: verify')
        }
        var cbs = 0
        var smallsSize = SMALLS_SIZE
        var st = {
          inthashCount: 0,
          inthashSize: 0,
          exthashCount: 0,
          exthashSize: 0
        }
        var flow = {
          internal: 0,
          external: 0,
          count: 0
        }
        var buff = Buffer.allocUnsafe(SMALLS_SIZE)
        var fail = Buffer.alloc(HASH_LENGTH)
        var send, kill
        [send, kill] = hasher(hashed, HASHER_N)
        function hashed (hash, extra) {
          --cbs
          if (!hash.equals(fail)) {
            extra[0].getMap(hash.toString('binary')).set(extra[1], extra[2])
          }
          if (cbs === 0) return done()
        }
        function done () {
          kill()
          if (opts.prompt) {
            tprintf(
              ['#Stat: verify: internal', szstr(st.inthashSize), st.inthashCount],
              ['#Stat: verify: external', szstr(st.exthashSize), st.exthashCount],
              ['#Stat: verify: total   ', szstr(st.inthashSize + st.exthashSize), st.inthashCount + st.exthashCount]
            )
            console.timeEnd('#Time: verify')
          }
          return resolve(devMap)
        }
        for (const sizeMap of devMap.values()) {
          for (const [size, exkeyMap] of sizeMap) {
            for (const contentMap of MapDeepIterator(exkeyMap, opts.extraKeys.length)) {
              const inoMap = contentMap.get('')
              if (inoMap) {
                if (inoMap.size > 1) {
                  for (const [ino, paths] of inoMap) {
                    if (size > smallsSize) {
                      st.exthashCount++
                      st.exthashSize += size
                      ++cbs
                      send(paths[0], [contentMap, ino, paths])
                    } else {
                      st.inthashCount++
                      st.inthashSize += size
                      let fd
                      try {
                        fd = fs.openSync(paths[0], 'r')
                        const hash = crypto.createHash(HASH_ALGORITHM)
                        fs.readSync(fd, buff, 0, size, null)
                        hash.update(buff.slice(0, size))
                        contentMap.getMap(hash.digest('binary')).set(ino, paths)
                      } catch (err) {
                        report(err)
                      }
                      if (fd) {
                        fs.close(fd, reportIf)
                      }
                    }
                    flow.count++
                    flow.external += size
                    smallsSize = SMALLS_SIZE * flow.external / (flow.internal + flow.external)
                    if (flow.count === 8) {
                      flow.count = 4
                      flow.internal >>= 1
                      flow.external >>= 1
                    }
                  }
                }
                contentMap.delete('')
              }
            }
          }
        }
        if (cbs === 0) return done()
      })
    }
    const solve = function (devMap) {
      if (opts.prompt) {
        console.time('#Time: solve')
      }
      const solutions = []
      for (const sizeMap of devMap.values()) {
        for (const [size, exkeyMap] of sizeMap) {
          for (const contentMap of MapDeepIterator(exkeyMap, opts.extraKeys.length)) {
            for (const inoMap of contentMap.values()) {
              if (inoMap.size > 1) {
                let nMajor = 0
                let iMajor = 0
                const dsts = []
                for (const [ino, paths] of inoMap) {
                  if (paths.length > nMajor) {
                    nMajor = paths.length
                    iMajor = ino
                  }
                }
                for (const [ino, paths] of inoMap) {
                  if (ino !== iMajor) {
                    dsts.push(...paths)
                  }
                }
                solutions.push([size, inoMap.get(iMajor)[0], dsts])
              }
            }
          }
        }
      }
      if (opts.prompt) {
        console.timeEnd('#Time: solve')
      }
      return solutions
    }
    const execute = function (solutions) {
      if (opts.prompt) {
        console.time('#Time: execute')
      }
      var st = {
        todo: {size: 0, src: 0, dst: 0},
        succ: {size: 0, src: 0, dst: 0},
        fail: {size: 0, src: 0, dst: 0}
      }
      for (const [size, src, dsts] of solutions) {
        let succ = 0
        let fail = 0
        for (const dst of dsts) {
          if (opts.verbose) {
            console.log(`ln -f -- '${src}' '${dst}'`)
          }
          if (opts.action) {
            try {
              link(src, dst)
              succ = 1
              st.succ.dst++
              st.succ.size += size
            } catch (err) {
              console.error(`ln -f -- '${src}' '${dst}' #${err}`)
              fail = 1
              st.fail.dst++
              st.fail.size += size
            }
          }
          st.todo.dst++
          st.todo.size += size
        }
        st.todo.src++
        st.succ.src += succ
        st.fail.src += fail
      }
      if (opts.prompt) {
        console.timeEnd('#Time: execute')
        tprintf(
          ['#Result: TODO:', szstr(st.todo.size), st.todo.src, st.todo.dst],
          ['#Result: DONE:', szstr(st.succ.size), st.succ.src, st.succ.dst],
          ['#Result: FAIL:', szstr(st.fail.size), st.fail.src, st.fail.dst]
        )
      }
    }
    probe({
      array: opts._,
      readline: opts.stdin ? readline.createInterface({input: process.stdin}) : undefined,
      filter: (function compileFilters () {
        const filter = {}
        try {
          { const filters = opts.fileFilters.map(eval)
            filter.file = function (stats, path) {
              try {
                for (const filter of filters) {
                  if (!filter(stats, path)) {
                    return false
                  }
                }
              } catch (err) {
                console.error(`${BASENAME}: filter runtime error:`)
                console.error(err)
                process.exit(1)
              }
              return true
            }
          }
          { const filters = opts.dirFilters.map(eval)
            filter.dir = function (stats, path, files) {
              try {
                for (const filter of filters) {
                  if (!filter(stats, path, files)) {
                    return false
                  }
                }
              } catch (err) {
                console.error(`${BASENAME}: filter runtime error:`)
                console.error(err)
                process.exit(1)
              }
              return true
            }
          }
        } catch (err) {
          console.error(`${BASENAME}: filter compilation error:`)
          console.error(err)
          process.exit(1)
        }
        return filter
      })(),
      exkeys: (function compileExtraKeys () {
        try {
          const calculator = opts.extraKeys.map(eval)
          return function (stats, path) {
            try {
              return calculator.map(calc => calc(stats, path))
            } catch (err) {
              console.error(`${BASENAME}: key calculator runtime error:`)
              console.error(err)
              process.exit(1)
            }
          }
        } catch (err) {
          console.error(`${BASENAME}: key calculator compilation error:`)
          console.error(err)
          process.exit(1)
        }
      })()
    })
      .then(verify)
      .then(solve)
      .then(execute)
  }
}
